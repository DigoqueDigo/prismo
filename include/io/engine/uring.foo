#ifndef URING_ENGINE_H
#define URING_ENGINE_H

#include <memory>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <thread>
#include <stdexcept>
#include <io/metric.h>
#include <io/logger.h>
#include <io/flag.h>
#include <iostream>

namespace Engine {
    template <typename LoggerT, typename MetricT>
    struct UringEngine {
        private:        
            LoggerT logger;
            UringConfig config;

            struct io_uring ring;
            std::vector<struct iovec> iovecs;
            std::thread poll_thread;

            std::atomic<uint32_t> submitted;
            std::atomic<bool> running;

            // inline int fsync(int fd);
            // inline int fdatasync(int fd);
            inline void read(int fd, size_t size, off_t offset, io_uring_sqe* sqe);
            inline void write(int fd, const void* buffer, size_t size, off_t offset, io_uring_sqe* sqe);

            
            public:
            explicit UringEngine(const UringConfig& _config, const LoggerT& _logger);
            ~UringEngine();
            
            int open(const char* filename, OpenFlags flags, mode_t mode);       
            void close(int fd);
            void poll_completion();
            
            template<Operation::OperationType OperationT>
            void submit(int fd, void* buffer, size_t size, off_t offset);
    };

        template<typename LoggerT, typename MetricT>
        UringEngine<LoggerT, MetricT>::UringEngine(const UringConfig& _config, const LoggerT& _logger)
            : logger(_logger), config(_config), iovecs(_config.batch), submitted(0), running(true) {

            int return_code = io_uring_queue_init_params(config.entries, &ring, &config.params);
            if (return_code) {
                throw std::runtime_error("Uring initialization failed: " + std::string(strerror(return_code)));
            }

            for (auto& iv : iovecs) {
                iv.iov_len = config.block_size;
                if (posix_memalign(&iv.iov_base, 4096, config.block_size))
                    throw std::bad_alloc();
                std::memset(iv.iov_base, 0, config.block_size);
            }

            return_code = io_uring_register_buffers(&ring, iovecs.data(), iovecs.size());
            if (return_code) {
                io_uring_queue_exit(&ring);
                throw std::runtime_error("Uring register buffers failed: " + std::string(strerror(errno)));
            }

            poll_thread = std::thread([this]() {
                this->poll_completion();
            });
    
            int CPU_CORE = 1;
            cpu_set_t cpuset;
            CPU_ZERO(&cpuset);
            CPU_SET(CPU_CORE, &cpuset);
            int s = pthread_setaffinity_np(poll_thread.native_handle(), sizeof(cpu_set_t), &cpuset);
            if (s != 0) {
                std::cerr << "Warning: failed to pin poll thread to CPU " << CPU_CORE << std::endl;
            }
        }


        template<typename LoggerT, typename MetricT>
        UringEngine<LoggerT, MetricT>::~UringEngine() {
            running = false;
            if (poll_thread.joinable()) {
                poll_thread.join();
            }

            for (auto& iv : iovecs) {
                std::free(iv.iov_base);
            }
            io_uring_queue_exit(&ring);
        }


    template<typename LoggerT, typename MetricT>
    int UringEngine<LoggerT, MetricT>::open(const char* filename, OpenFlags flags, mode_t mode) {
        int fd = ::open(filename, flags.value, mode);
        if (fd < 0) {
            throw std::runtime_error("Failed to open file: " + std::string(strerror(errno)));
        }
        int return_code = io_uring_register_files(&this->ring, &fd, 1);
        if (return_code) {
            throw std::runtime_error("Register file failed: " + std::string(strerror(return_code)));
        }
        return 0;
    }

    template<typename LoggerT, typename MetricT>
    inline void UringEngine<LoggerT, MetricT>::read(int fd_index, size_t size, off_t offset, io_uring_sqe* sqe) {
        int index = this->submitted % this->config.batch;
        io_uring_prep_read_fixed(sqe, fd_index, this->iovecs[index].iov_base, size, offset, index);
        sqe->flags |= IOSQE_FIXED_FILE;
        this->submitted++;
    }

    template<typename LoggerT, typename MetricT>
    inline void UringEngine<LoggerT, MetricT>::write(int fd_index, const void* buffer, size_t size, off_t offset, io_uring_sqe* sqe) {
        // TODO :: uncomment deste merda
        // std::memcpy(this->iovecs[this->submitted].iov_base, buffer, this->config.block_size);
        (void)  buffer;
        int index = this->submitted % this->config.batch;
        io_uring_prep_write_fixed(sqe, fd_index, this->iovecs[index].iov_base, size, offset, index);
        sqe->flags |= IOSQE_FIXED_FILE;
        this->submitted++;
    }

    template<typename LoggerT, typename MetricT>
    void UringEngine<LoggerT, MetricT>::close(int fd) {
        if (io_uring_unregister_files(&ring)) {
            throw std::runtime_error("Failed to unregister files: " + std::string(strerror(errno)));
        }
        if (::close(fd) < 0) {
            throw std::runtime_error("Failed to close fd: " + std::string(strerror(errno)));
        }
        if (io_uring_unregister_buffers(&ring)) {
            throw std::runtime_error("Failed to unregister buffers: " + std::string(strerror(errno)));
        }
    }

    template<typename LoggerT, typename MetricT>
    template<Operation::OperationType OperationT>
    void UringEngine<LoggerT, MetricT>::submit(int fd, void* buffer, size_t size, off_t offset) {

        io_uring_sqe* sqe = io_uring_get_sqe(&this->ring);
        // std::cout << "submitted: " << this->submitted << std::endl;

        while (sqe == nullptr) {
            io_uring_submit(&ring);
            sqe = io_uring_get_sqe(&this->ring);
        }

        if constexpr (OperationT == Operation::OperationType::READ) {
            this->read(fd, size, offset, sqe);
        } else if constexpr (OperationT == Operation::OperationType::WRITE) {
            this->write(fd, buffer, size, offset, sqe);
        }
    }

    template<typename LoggerT, typename MetricT>
    inline void UringEngine<LoggerT, MetricT>::poll_completion(void) {
        int count = 0;
        std::vector<io_uring_cqe*> cqe_batch(this->config.batch);
        
        while (this->running) {
            count = io_uring_peek_batch_cqe(&ring, cqe_batch.data(), cqe_batch.size());
        
            for (int index = 0; index < count; index++) {
                io_uring_cqe* cqe = cqe_batch[index];
                io_uring_cqe_seen(&ring, cqe);
                // std::cout << "Return: " << cqe->res << std::endl;
            }
            // std::cout << "completed: " << count << std::endl;
            std::this_thread::yield();
        }
    }
};

#endif
